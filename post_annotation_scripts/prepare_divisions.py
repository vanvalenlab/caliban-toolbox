"""
python celltk/postprocess.py -f gap_closing -i c0/img_00000000* -l c2/img_00000000*  -o c3 -p DISPLACEMENT=30
"""

from scipy.ndimage import imread
from os.path import basename, join
import numpy as np
import detect_div
from celltk.utils.postprocess_utils import regionprops, LCell # set default parent and next as None
from celltk.utils.file_io import make_dirs, imsave, lbread
from celltk.utils.filters import labels2outlines
from scipy.ndimage import binary_dilation
import logging
import os
#logger = logging.getLogger(__name__)


def cells2labels(cells, frame, labels):
    inframe = [i for i in cells if i.frame == frame]
    template = np.zeros(labels.shape)
    for cell in inframe:
        template[labels == cell._original_label] = cell.label
        if cell.parent is not None:
            outline = labels2outlines(binary_dilation(template == cell.label))
            # outline = labels2outlines(template == cell.label)
            template[outline > 0] = -cell.parent
    return template


def caller(inputs, inputs_labels, output, functions, params, output_dir):
    make_dirs(output)

    # Make cells. cells are a list of regionproperties or subclasses.
    #logger.info('Postprocess.\tcollecting cells...')
    store = []
    for frame, (path, pathl) in enumerate(zip(inputs, inputs_labels)):
        img, labels = imread(path), lbread(pathl)
        cells = regionprops(labels, img)
        cells = [LCell(cell) for cell in cells]
        for cell in cells:
            cell.frame = frame
            if frame > 0:
                all_labels = [i.label for i in store[frame - 1]]
                if cell.label in all_labels:
                    store[frame - 1][all_labels.index(cell.label)].nxt = cell
        store.append(cells)
    cells = [i for j in store for i in j]
    # Each function receives cells (regionprops) and finally return labels generated by cells.label
    for function, param in zip(functions, params):
        func = getattr(detect_div, function)
        print('caller', output_dir)
        cells = func(cells, **params, output_dir=output_dir)

    for frame, (path, pathl) in enumerate(zip(inputs, inputs_labels)):
        labels = cells2labels(cells, frame, lbread(pathl))
        imsave(labels, output, path, dtype=np.int16)


def celltknew(direc, output_direc):
    dir = direc
    print('hi')
    inputs = os.listdir(dir + 'raw/')
    inputslst = []
    for term in inputs:
        inputslst.append(dir + 'raw/' + term)

    inputs_labels = os.listdir(dir + 'annotated/')
    inputs_labelslst = []
    for term in inputs_labels:
        inputs_labelslst.append(dir + 'annotated/' + term)

    inputslst.sort()
    inputs_labelslst.sort()
    output = os.path.join(dir, 'nuc')
    functions = ['detect_division']
    params = {'DIVISIONMASSERR': 0.35, 'DISPLACEMENT': 50}
    print(dir)
    caller(inputslst, inputs_labelslst, output, functions, params, dir)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    celltknew()
